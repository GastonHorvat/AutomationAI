---
// src/components/Chatbot.astro
import { Image } from 'astro:assets';
import chatbotIcon from '../assets/images/chatbot.png';

const webhookUrlFromEnv = import.meta.env.PUBLIC_MAKE_WEBHOOK_URL;
const chatbotTokenFromEnv = import.meta.env.PUBLIC_CHATBOT_SECRET_TOKEN;
---

<div
  id="chatbot-container"
  data-webhook-url={webhookUrlFromEnv}
  data-chatbot-token={chatbotTokenFromEnv}
>
  <button id="chatbot-toggle-button" aria-label="Abrir chat de NahIA">
    <Image src={chatbotIcon} alt="Abrir chat" width="48" height="48" />
  </button>

  <div id="chatbot-window" class="hidden">
    <header id="chatbot-header">
      <span id="chatbot-title">NahIA</span>
      <button id="chatbot-close-button" aria-label="Cerrar chat">칑</button>
    </header>
    <div id="chatbot-messages">
      {/* Los mensajes se insertar치n aqu칤 por JS */}
    </div>
    <form id="chatbot-form">
      <input type="text" id="chatbot-input" placeholder="Escribe tu mensaje..." autocomplete="off" />
      <button type="submit" id="chatbot-send-button" aria-label="Enviar mensaje">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
      </button>
    </form>
  </div>
</div>

<script>
  // Importar DOMPurify. Si este script no se procesa como un m칩dulo,
  // necesitar치s cargar DOMPurify de otra manera (ej. CDN y acceso global)
  import DOMPurify from 'dompurify';

  // --- 1. OBTENCI칍N DE ELEMENTOS DOM ---
  const chatbotContainer = document.getElementById('chatbot-container') as HTMLDivElement | null;
  const chatbotToggleButton = document.getElementById('chatbot-toggle-button') as HTMLButtonElement | null;
  const chatbotWindow = document.getElementById('chatbot-window') as HTMLDivElement | null;
  const chatbotCloseButton = document.getElementById('chatbot-close-button') as HTMLButtonElement | null;
  const chatbotMessages = document.getElementById('chatbot-messages') as HTMLDivElement | null;
  const chatbotForm = document.getElementById('chatbot-form') as HTMLFormElement | null;
  const chatbotInput = document.getElementById('chatbot-input') as HTMLInputElement | null;

  // --- 2. CONSTANTES Y VARIABLES DE ESTADO GLOBALES DEL SCRIPT ---
  const WELCOME_MESSAGE_HTML = "<p>춰Hola! 游녦 Soy NahIA. 쯃isto para descubrir c칩mo la IA puede transformar tu negocio? 춰Preg칰ntame lo que quieras!</p>";
  let isChatOpen = false;

  // --- 3. CONFIGURACI칍N Y L칍GICA DE SESI칍N/HISTORIAL/ESTADO ---
  const MAKE_WEBHOOK_URL = chatbotContainer?.dataset.webhookUrl || '';
  const CHATBOT_SECRET_TOKEN = chatbotContainer?.dataset.chatbotToken || '';
  const SESSION_ID_KEY = 'nahia_session_id';
  const CHAT_HISTORY_KEY_PREFIX = 'nahia_chat_history_';
  const CHAT_OPEN_STATE_KEY = 'nahia_chat_open_state';

  interface ChatMessage {
    content: string; // Ahora puede ser HTML para el bot, o texto para el usuario
    sender: 'user' | 'bot';
    timestamp: string;
  }

  function generateUUIDv4(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  function getChatHistoryKey(sessionId: string = currentSessionId): string {
    return CHAT_HISTORY_KEY_PREFIX + sessionId;
  }
  
  function getSessionId(): string {
    let sessionId = localStorage.getItem(SESSION_ID_KEY);
    if (!sessionId) {
      sessionId = generateUUIDv4();
      localStorage.setItem(SESSION_ID_KEY, sessionId);
      console.log('Nueva sessionId generada y guardada:', sessionId);
      localStorage.removeItem(getChatHistoryKey(sessionId));
      localStorage.setItem(CHAT_OPEN_STATE_KEY, 'false');
    }
    return sessionId;
  }
  
  let currentSessionId = getSessionId();
  console.log('Current sessionId al cargar:', currentSessionId);

  // --- 4. FUNCIONES DE MANEJO DE HISTORIAL EN LOCALSTORAGE ---
  function loadChatHistory(): ChatMessage[] {
    if (!chatbotMessages) return [];
    chatbotMessages.innerHTML = '';
    const historyKey = getChatHistoryKey();
    const storedHistory = localStorage.getItem(historyKey);
    if (storedHistory) {
      try {
        const messages: ChatMessage[] = JSON.parse(storedHistory);
        messages.forEach(msg => addMessageToChatDOM(msg.content, msg.sender));
        console.log(`Historial cargado para la sesi칩n ${currentSessionId}:`, messages.length, "mensajes");
        return messages;
      } catch (e) {
        console.error('Error al parsear el historial del chat desde localStorage:', e);
        localStorage.removeItem(historyKey);
        return [];
      }
    }
    console.log(`No se encontr칩 historial para la sesi칩n ${currentSessionId}.`);
    return [];
  }

  function saveMessageToHistory(content: string, sender: 'user' | 'bot') {
    const historyKey = getChatHistoryKey();
    let messages: ChatMessage[] = [];
    const storedHistory = localStorage.getItem(historyKey);
    if (storedHistory) {
      try {
        messages = JSON.parse(storedHistory);
      } catch (e) {
        console.error('Error al parsear historial existente antes de guardar, se resetea:', e);
        messages = [];
      }
    }
    
    const newMessage: ChatMessage = { content, sender, timestamp: new Date().toISOString() };
    messages.push(newMessage);

    try {
      localStorage.setItem(historyKey, JSON.stringify(messages));
    } catch (e) {
      console.error('Error al guardar mensaje en localStorage (posiblemente lleno):', e);
    }
  }

  // --- 5. FUNCIONES PRINCIPALES DEL CHATBOT ---
  /**
   * A침ade un mensaje (texto o HTML sanitizado para el bot) al DOM del chat.
   */
  function addMessageToChatDOM(content: string, sender: 'user' | 'bot' | 'bot-thinking'): HTMLDivElement | undefined {
    if (!chatbotMessages) return undefined;

    const messageElement = document.createElement('div');
    messageElement.classList.add('chatbot-message', `chatbot-message-${sender}`);
    
    // Usamos un div como 'burbuja' para que el HTML del bot tenga un contenedor propio
    // que no sea un <p> por si el HTML ya contiene p치rrafos.
    const messageBubble = document.createElement('div');
    messageBubble.classList.add('message-bubble-content'); // Clase para estilizar si es necesario
    
    if (sender === 'bot') {
      // Sanitizar el HTML del bot antes de insertarlo
      messageBubble.innerHTML = DOMPurify.sanitize(content, {
          USE_PROFILES: { html: true } // Permite etiquetas HTML comunes y seguras
          // Puedes configurar DOMPurify m치s a fondo si necesitas:
          // ALLOWED_TAGS: ['p', 'b', 'i', 'u', 'a', 'ul', 'li', 'br', 'span', 'img', 'strong', 'em'],
          // ALLOWED_ATTR: ['href', 'target', 'src', 'alt', 'style'] // Cuidado con 'style' si permites mucho
      });
    } else {
      // Para mensajes del usuario y "pensando", usar textContent para seguridad
      // (y porque no deber칤an ser HTML).
      // Envolvemos el texto del usuario en un <p> para consistencia visual si el bot usa <p>.
      const p = document.createElement('p');
      p.textContent = content;
      messageBubble.appendChild(p);
    }
    
    messageElement.appendChild(messageBubble);
    chatbotMessages.appendChild(messageElement);
    chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
    return messageElement;
  }

  function setChatOpenState(open: boolean, isInitialLoad = false) {
    if (!chatbotWindow || !chatbotToggleButton || !chatbotInput) return;

    isChatOpen = open;
    chatbotWindow.classList.toggle('hidden', !open);
    chatbotToggleButton.setAttribute('aria-expanded', String(open));
    
    if (!isInitialLoad) {
        localStorage.setItem(CHAT_OPEN_STATE_KEY, String(open));
    }

    if (open) {
      const loadedMessages = loadChatHistory();
      if (loadedMessages.length === 0) {
        // El mensaje de bienvenida ahora es HTML
        addMessageToChatDOM(WELCOME_MESSAGE_HTML, 'bot');
        saveMessageToHistory(WELCOME_MESSAGE_HTML, 'bot');
      }
      chatbotInput.focus();
    }
    console.log(`Chat window state set to: ${open ? 'open' : 'closed'}. Initial load: ${isInitialLoad}`);
  }

  function toggleChatWindow() {
    setChatOpenState(!isChatOpen); 
  }

  async function handleSendMessage(event: Event) {
    event.preventDefault();
    const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

    if (!MAKE_WEBHOOK_URL || !CHATBOT_SECRET_TOKEN) {
      console.error("Chatbot Config Error: Webhook URL o Token no definido.");
      addMessageToChatDOM("<p>Error de configuraci칩n. No se puede contactar a NahIA.</p>", 'bot');
      return;
    }
    if (!chatbotInput || chatbotInput.value.trim() === '') {
      if (!chatbotInput) console.error("Chatbot Error: Input no encontrado.");
      return;
    }

    const userMessageText = chatbotInput.value.trim(); // El mensaje del usuario es siempre texto plano
    addMessageToChatDOM(userMessageText, 'user');
    saveMessageToHistory(userMessageText, 'user'); // Guardar como texto

    const currentMessageValue = chatbotInput.value;
    if(chatbotInput) chatbotInput.value = '';

    const thinkingMessage = addMessageToChatDOM("NahIA est치 pensando...", 'bot-thinking');

    try {
      const response = await fetch(MAKE_WEBHOOK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          timestamp: new Date().toISOString(),
          userTimezone: userTimezone,
          source: 'NahIA Chatbot',
          userMessage: userMessageText, // Enviar el texto plano del usuario
          sessionId: currentSessionId,
          chatbot_token: CHATBOT_SECRET_TOKEN
        }),
      });

      if (thinkingMessage && thinkingMessage.parentElement === chatbotMessages && chatbotMessages) {
          chatbotMessages.removeChild(thinkingMessage);
      }

      if (!response.ok) {
        // ... (manejo de errores similar, pero ahora los mensajes de error del bot tambi칠n pueden ser HTML simple)
        let errorDetail = `Status: ${response.status}`;
        try { const errorBodyText = await response.text(); if (errorBodyText) errorDetail += ` - ${errorBodyText.substring(0, 200)}`; } catch (e) { /* Ignorar */ }
        console.error('Error desde Make.com:', errorDetail);
        const displayError = response.status === 401 || response.status === 403
          ? `<p>Error de autenticaci칩n con NahIA. Verifique la configuraci칩n.</p>`
          : `<p>Hubo un problema con NahIA. (Error: ${response.status})</p>`;
        addMessageToChatDOM(displayError, 'bot');
        if(chatbotInput) chatbotInput.value = currentMessageValue;
        return;
      }

      const responseText = await response.text(); // Obtener como texto primero
      let data;
      try {
        data = JSON.parse(responseText); // Intentar parsear como JSON
      } catch (e) {
        console.error('Error al parsear respuesta JSON de Make.com:', e, "\nRespuesta recibida:", responseText.substring(0, 500));
        addMessageToChatDOM("<p>NahIA envi칩 una respuesta en un formato inesperado. Intenta de nuevo.</p>", 'bot');
        return;
      }
      

      if (data && data.botResponse && typeof data.botResponse === 'string') {
        // botResponse ahora es un string HTML
        addMessageToChatDOM(data.botResponse, 'bot');
        saveMessageToHistory(data.botResponse, 'bot'); // Guardar el HTML en el historial
      } else {
        console.error('Respuesta OK, pero sin data.botResponse (string HTML) esperado:', data);
        addMessageToChatDOM('<p>NahIA tuvo un peque침o desliz al responder. Intenta de nuevo.</p>', 'bot');
      }

    } catch (error) {
       if (thinkingMessage && thinkingMessage.parentElement === chatbotMessages && chatbotMessages) {
          chatbotMessages.removeChild(thinkingMessage);
      }
      let errorMessage = '<p>Error de conexi칩n con NahIA. Intenta de nuevo m치s tarde.</p>';
      if (error instanceof Error) {
          errorMessage = `<p>Error al procesar la respuesta de NahIA: ${error.message.substring(0, 100)}</p>`;
      }
      console.error('Catch block error en handleSendMessage:', error);
      addMessageToChatDOM(errorMessage, 'bot');
      if(chatbotInput) chatbotInput.value = currentMessageValue;
    }
  }

  // --- 6. ASIGNACI칍N DE EVENT LISTENERS E INICIALIZACI칍N ---
  document.addEventListener('DOMContentLoaded', () => {
    
    currentSessionId = getSessionId(); 

    const savedOpenState = localStorage.getItem(CHAT_OPEN_STATE_KEY);
    const shouldBeOpen = savedOpenState === 'true'; 
    
    setChatOpenState(shouldBeOpen, true);

    if (chatbotToggleButton) {
      chatbotToggleButton.addEventListener('click', toggleChatWindow);
    }
    if (chatbotCloseButton) {
      chatbotCloseButton.addEventListener('click', toggleChatWindow);
    }
    if (chatbotForm) {
      chatbotForm.addEventListener('submit', handleSendMessage);
    }
    console.log('Event listeners adjuntados y script de chatbot inicializado.');
  });
</script>

<style is:global>
  /* 
    Usamos is:global temporalmente para los estilos principales del contenedor y bot칩n flotante
    para asegurar que se apliquen correctamente, especialmente si hay estilos globales muy espec칤ficos.
    Lo ideal a largo plazo ser칤a encapsular todo o usar capas CSS.
    Para este desaf칤o r치pido, esto nos da m치s control.
  */

  :root {
    /* Define tus colores aqu칤 si no est치n ya globales, o usa los que tienes.
       Estos son ejemplos, aj칰stalos a tus --primary-color y --secondary-color */
    --chatbot-primary-color: var(--primary-color, #0052cc); /* Azul por defecto si --primary-color no est치 */
    --chatbot-secondary-color: var(--secondary-color, #DE350B); /* Rojo por defecto si --secondary-color no est치 */
    --chatbot-text-color: #333;
    --chatbot-bg-light: #ffffff;
    --chatbot-bg-user-message: #e6f2ff; /* Un azul claro para mensajes de usuario */
    --chatbot-bg-bot-message: #f0f0f0; /* Un gris claro para mensajes de bot */
    --chatbot-border-color: #e0e0e0;
    --chatbot-header-text-color: #ffffff !important; /* A칌ADIDO: Color para el texto del header */
  }

  #chatbot-container {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 1000;
  }

  #chatbot-toggle-button {
    background-color: var(--chatbot-primary-color);
    color: white; /* El color del texto por si acaso, pero la imagen es lo principal */
    border: none;
    border-radius: 50%;
    width: 72px; /* AUMENTADO: Tama침o del bot칩n */
    height: 72px; /* AUMENTADO: Tama침o del bot칩n */
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25); /* Sombra un poco m치s pronunciada */
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
  }

  #chatbot-toggle-button:hover {
    transform: scale(1.08); /* Un poco menos de zoom para un bot칩n m치s grande */
    box-shadow: 0 6px 14px rgba(0, 0, 0, 0.35);
  }

  #chatbot-toggle-button img {
    width: 48px; /* AUMENTADO: Tama침o de la imagen interna */
    height: 48px; /* AUMENTADO: Tama침o de la imagen interna */
    object-fit: contain;
    filter: brightness(0) invert(1); /* NUEVO: Intenta hacer la imagen blanca */
  }

  #chatbot-window {
    background-color: var(--chatbot-bg-light);
    border: 1px solid var(--chatbot-border-color);
    border-radius: 10px; /* Un poco m치s de radio */
    box-shadow: 0 8px 25px rgba(0,0,0,0.4); /* Sombra m치s notoria para la ventana */
    width: 90vw;    /* 90% del ancho del viewport */
    max-width: 450px; /* Pero no m치s de 450px */
    max-height: 80vh; 
    display: flex;
    flex-direction: column;
    position: absolute; 
    bottom: 85px; /* Ajustar si el bot칩n es m치s grande: 72px + 20px (espacio) + un poco m치s */
    right: 0;
    overflow: hidden; 
    transition: opacity 0.3s ease, transform 0.3s ease;
  }

  #chatbot-window.hidden {
    display: none;
  }

#chatbot-header {
  background-color: var(--chatbot-primary-color);
  color: var(--chatbot-header-text-color, #ffffff); /* Color base para el header */
  padding: 14px 18px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-top-left-radius: 10px; 
  border-top-right-radius: 10px;
}

#chatbot-title { 
  font-size: 1.2em; 
  font-weight: 600; 
  margin-right: 10px; /* Space before close button */
  /* Allow title to wrap if needed, remove fixed width behavior from previous attempt */
  white-space: normal; 
  overflow: visible; /* Ensure it's not hidden if it wraps */
  text-overflow: clip; /* Default, no ellipsis if wrapping */
}

#chatbot-close-button {
  background: none;
  border: none;
  color: inherit; /* Deber칤a heredar de #chatbot-header */
  font-size: 1.9em;
  line-height: 1;
  cursor: pointer;
  padding: 0 5px;
  flex-shrink: 0; /* Prevent button from shrinking */
}

  #chatbot-messages {
    flex-grow: 1;
    padding: 15px;
    overflow-y: auto;
    min-height: 200px; /* Altura m칤nima para que se vea algo aun sin mensajes */
    max-height: calc(80vh - 120px); /* Ajusta seg칰n header y form */
    background-color: #f9f9f9; /* Un fondo ligeramente diferente para el 치rea de mensajes */
  }

  #chatbot-messages .chatbot-message { /* Increased specificity */
    margin-bottom: 12px;
    display: flex;
    width: 100%; /* Ensure this flex container takes full width */
  }

  #chatbot-messages .chatbot-message p { /* Increased specificity */
    padding: 10px 14px;
    border-radius: 18px;
    max-width: 80%;
    margin: 0;
    line-height: 1.4;
    overflow-wrap: break-word;
    display: inline-block; /* Allows max-width and fits content */
    text-align: left;      /* Explicit text alignment */
  }

  .chatbot-message-user {
    justify-content: flex-end; /* Alinea a la derecha */
  }
  .chatbot-message-user p {
    background-color: var(--chatbot-bg-user-message); /* Azul claro */
    color: var(--chatbot-text-color);
    border-bottom-right-radius: 4px; /* Estilo "burbuja" */
  }

  .chatbot-message-bot {
    justify-content: flex-start; /* Alinea a la izquierda */
  }
  .chatbot-message-bot p {
    background-color: var(--chatbot-bg-bot-message); /* Gris claro */
    color: var(--chatbot-text-color);
    border-bottom-left-radius: 4px; /* Estilo "burbuja" */
  }


  #chatbot-form {
    display: flex;
    padding: 10px 15px;
    border-top: 1px solid var(--chatbot-border-color);
    background-color: var(--chatbot-bg-light);
  }

  #chatbot-input {
    flex-grow: 1;
    border: 1px solid #ccc;
    border-radius: 20px;
    padding: 10px 15px;
    margin-right: 10px;
    font-size: 0.95em;
    outline: none;
  }
  #chatbot-input:focus {
    border-color: var(--chatbot-primary-color);
    box-shadow: 0 0 0 2px var(--chatbot-primary-color, #0052cc)33; /* Un suave outline al hacer focus */
  }

  #chatbot-send-button {
    background-color: var(--chatbot-primary-color);
    color: white;
    border: none;
    border-radius: 50%;
    width: 44px;
    height: 44px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    flex-shrink: 0; /* Para que no se encoja */
  }
  #chatbot-send-button:hover {
    opacity: 0.9;
  }
  #chatbot-send-button svg {
    width: 20px;
    height: 20px;
  }

.chatbot-message-bot-thinking p { /* Estilo para el mensaje de "pensando" */
  background-color: var(--chatbot-bg-bot-message);
  color: #777; /* Un color m치s tenue */
  font-style: italic;
}

  /* Media query para pantallas m치s peque침as (ej. m칩viles) */
 @media (max-width: 480px) {
    /* Default state for mobile window (when hidden or not explicitly fullscreen) */
    #chatbot-window {
      /* These might be overridden by :not(.hidden) below if chat is open */
      width: calc(100vw - 30px); 
      max-width: 95%;
      bottom: 85px; 
      right: 5px; 
      left: auto;
    }

    /* Full height (below site header) styles when chat window is open on mobile */
  #chatbot-window:not(.hidden) { /* Fullscreen when open on mobile */
    position: fixed; /* Crucial change */
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%; /* Or 100vw */
    height: 100%; /* Or 100vh */
    max-width: none;
    max-height: none;
    border-radius: 0;
    z-index: 2000; /* Ensure it's above other elements, including the toggle button if container is lower z-index */
  }

    /* Adjust messages area max-height for the new layout */
  #chatbot-window:not(.hidden) #chatbot-messages {
    /* max-height: calc(80vh - 120px); -- Old value */
    /* New calculation: 100vh - header_height - form_height */
    /* Assuming header is ~50-60px, form is ~50-60px. */
    /* Let flex-grow handle it mostly, but a max-height is still good. */
    /* min-height will be more important if content is short */
    max-height: calc(100vh - 110px); /* Approximate, adjust if header/form heights are known */
  }
    
    #chatbot-toggle-button {
      width: 64px; 
      height: 64px;
      bottom: 15px;
      right: 15px;
      z-index: 2001; /* Ensure toggle button is accessible if window logic changes */
    }
    #chatbot-toggle-button img {
      width: 40px; 
      height: 40px;
    }
  }

</style>
